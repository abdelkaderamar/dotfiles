#! /bin/bash 
### Colors ################################################
RED='\033[0;31m'
GREEN='\033[0;32m'
BROWN='\033[0;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
YELLOW='\033[1;33m'
NC='\033[0m'

### Logging ################################################
function e_header()  { echo -e "\n\033[1m$@\033[0m"; }
function e_success() { echo -e " \033[1;32m✔\033[0m  $@"; }
function e_error()   { echo -e " \033[1;31m✖\033[0m  $@"; }
function e_arrow()   { echo -e " \033[1;34m➜\033[0m  $@"; }
function e_warn()    { echo -e " \033[1;31m➜\033[0m  $@"; }
function echo_and_exit()
{
  exit_code=$1
  shift
  e_error "$@"
  exit $exit_code
}

### Create a directory than move all the files passed as
### parameter to it
function dirndmv()
{
  if [ $# -lt 2 ]
  then
    e_error 'Usage: dirndmv.sh <dir> {files}'
    return 1
  fi

  dir="$1"
  shift

  mkdir -p "$dir" && mv -vi "$@" "$dir"
}

function gpull_all()
{
  if [ $# -eq 0 ]
  then
    set -- *
  fi
    for i in "$@"
    do
      if [ -d "$i" ]
      then
        echo "$i"
        cd "$i"
        git pull
        cd - > /dev/null
      fi
    done
}

function gstatus_all()
{
  if [ $# -eq 0 ]
  then
    set -- *
  fi
    for i in "$@"
    do
      if [ -d "$i" ]
      then
        cd "$i"
        res=$(git status -s)
        if [ ! -z "$res" ]
        then
          e_arrow "$i modified file(s):"
          echo "$res"
          echo
        fi

        cd - > /dev/null
      fi
    done
}

function unpushed_commit()
{
  if [ $# -eq 0 ]
  then
    set -- *
  fi
    for i in "$@"
    do
      if [ -d "$i" ]
      then
        #echo "$i"
        cd "$i"
        res=$(git log origin/master..HEAD)
        if [ ! -z "$res" ]
        then
          e_arrow "$i unpublished commit(s):"
          echo "$res"
          echo
        fi
        cd - > /dev/null
      fi
    done
}

### Convert code to latex compatible text
function code2tex()
{
  for i in "$@"
  do
    echo $i | sed 's/\([{}_$]\)/\\\1/g'
  done
}

## Scan an A4 color page with hp-scan
function hp-scan-a4() 
{
  [[ $# -lt 1 ]] && echo Missing filename && return 1
  output_file="$1"
  hp-scan -mcolor -r400 --size=a4 --file="$output_file"
}
function hp-scan-a4-device()
{
  [[ $# -lt 2 ]] && echo Missing filename or device && return 1
  output_file="$1"

  if [ -f "$output_file" ]
  then
      e_warn "File [$output_file] exists. Overwrite (y/n) ? "
      read answer
      if [ "$answer" != "y" ]
      then
	  return 1
      fi
  fi
  
  device="$2"
  hp-scan --device="$device" -mcolor -r400 --size=a4 --file="$output_file"
}
function hp-scan-a4-hp5200() 
{
  [[ $# -lt 1 ]] && echo Missing filename && return 1
  output_file="$1"
  device="hpaio:/net/OfficeJet_5200_series?ip=192.168.1.31"
  #device='hpaio:/net/OfficeJet_5200_series?hostname=HP84A93EBDF464.local'
  hp-scan-a4-device "$output_file" "$device"
}

img2pdfa4portrait() {
    if [ $# -ne 1 -a $# -ne 2 ]
    then
	e_error "Usage: img2pdfa4 <input file> [<output file>]"
	return 1
    fi
    
    local in="$1"
    local ext="${in##*.}"
    local out="${in%$ext}pdf"
    if [ $# -eq 2 ]
    then
	out="$2"
    fi
    convert "$in" -background white -page a4 "$out"
}

img2pdfa4landscape() {
    if [ $# -ne 1 -a $# -ne 2 ]
    then
	e_error "Usage: img2pdfa4 <input file> [<output file>]"
	return 1
    fi
    
    local in="$1"
    local ext="${in##*.}"
    local out="${in%$ext}pdf"
    if [ $# -eq 2 ]
    then
	out="$2"
    fi
    convert "$in" -background white -page a4 -rotate 90 "$out"
}

pdf2a4() {
    for i in "$@"
    do
	pdfjam --outfile "a4-${i}" --paper a4paper "$i"
    done
}

merge_pdf() {
    if [ $# -lt 3 ]
    then
	e_error "Usage: merge_pdf {<input files>} <output file>"
	return 1
    fi
    local output="${@:$#}"
    if [ -f "$output" ]
    then
	e_warn "$output exists. Do you want to overwrite it (y/n)?"
	read l
	if [ "$l" != "y" ]
	then
	    return 1
	fi
    fi
    local prev_last="${#@}"
    prev_last=$((prev_last-1))
    local input=( "$@" )
    input=( "${input[@]:0:$prev_last}" )
    e_header "Concatenating files ${input[@]} ..."
    pdftk "${input[@]}" cat output "$output"
    res=$?
    if [ $res -eq 0 ]
    then
	e_success "File $output generated successfuly"
    else
	e_error "Failed to generate the file $output"
    fi
    return $res
}

mkv2mp4() {
    if [ $# -ne 1 -a $# -ne 2 ]
    then
	e_error "Usage: mkv2mp4 <input file> [<output file>]"
	return 1
    fi
    
    local in="$1"
    local ext="${in##*.}"
    local out="${in%$ext}mp4"
    if [ $# -eq 2 ]
    then
	out="$2"
    fi
    ffmpeg -i "$in" -vcodec copy -acodec aac -strict -2 "$out"
    res=$?
    if [ $res -eq 0 ]
    then
	e_success "File $out generated successfuly"
    else
	e_error "Failed to generate the file $out"
    fi
    return $res
}

audiotrack2mp3() {
    if [ $# -ne 2 ]
    then
	e_error "Usage: audiotrack2mp3 <input file> <output file>"
	return 1
    fi
    
    local in="$1"
    local out="$2"

    ffmpeg -i "$in" -c:v copy -c:a mp3 "$out"
    res=$?
    if [ $res -eq 0 ]
    then
	e_success "File $out generated successfuly"
    else
	e_error "Failed to generate the file $out"
    fi
    return $res
}

odd_even_merge() {
    if [ $# -ne 3 ]
    then
	e_error "Usage: odd_even_merge <odd file> <even file> <output file>"
	e_arrow '       odd = impair &&   even = pair'
	return 1
    fi
    local odd="$1"
    local even="$2"
    local output="$3"
    
    pdftk A="$odd" B="$even" shuffle A B output "$output"
    
}

pdf_one_per_page() {
    if [ $# -ne 1 ]
    then
	e_error "Usage: pdf_one_per_page <input file>"
	return 1
    fi
    
    local input="$1"
    local output_format="${input,,}"
    output_format="${output_format%.pdf}"-page-%d.pdf
    
    pdftk "$input" burst output "$output_format"
}

extract_pdf_pages() {
    if [ $# -lt 2 ]
    then
	e_error "Usage extract_pdf_pages <input file> {intervals ...}"
	return 1
    fi
    local input="$1"
    shift
    local output=${input,,}
    output=pages_$@.pdf
    output=${output// /+}
    local tmp=${input,,}
    tmp=${tmp%.pdf}
    output=$tmp-$output
    pdftk "$input" cat $@ output "$output"
}

iso_mount() {
    if [ $# -ne 2 ]
    then
      e_error "Syntax error"
      e_error "Usage: ${FUNCNAME[0]} <iso file> <mount dir>"
      return 1
    fi
    e_header "Mount iso file to a directory (sudo mount -o loop -t iso9660 <iso file> <mounting dir>)"
    echo
    echo
    sudo mount -o loop -t iso9660 "$1" "$2"
    return $?
}

iso_make() {
    if [ $# -ne 2 -a $# -ne 1 ]
    then
      e_error "Syntax error"
      e_error "Usage: ${FUNCNAME[0]} <dir> [<iso file>]"
      return 1
    fi
    local dir="$1"
    dir="${dir%/}"
    if [ $# -eq 1 ]
    then
      local iso_file="${dir}".iso
    else
      local iso_file="$2"
    fi
    e_header "Create an iso file from a directory (mkisofs <iso file> <dir>)"
    echo 
    genisoimage -o "$iso_file" -J -R -l -joliet-long "$dir"
    return $?
}

dv2mp4() {
    local help_message="Usage: dv2mp4 {<dv file>}"
    if [ $# -eq 0 ]
    then
	e_header "$help_message"
	return 1
    fi

    local files=( )
    while [ $# -gt 0 ]
    do
	case "$1" in
	    -h|--help)
		e_header "$help_message"
		;;
	    *)   files+=("$1")
		 ;;
	esac
	shift
    done
    for f in "${files[@]}"
    do
	e_header "Processing $f"
        ffmpeg -i  "$f" -deinterlace -vcodec h264 -acodec mp3 \
	       "${f%.dv}.mp4"
	if [ $? -ne 0 ]
	then
		echo "Error processing [$f]" >> dv2mp4.err
	fi
    done

}

function remove_duplicates() {
    local usage_message="Usage: ${FUNCNAME[0]} <favorite dir> <dir> [-r]"
    if [ $# -eq 1 -a "$1" = "-h" ]
    then
	e_header "$usage_message"
	echo
	return 0
    fi
    if [ $# -ne 2 -a $# -ne 3 ]
    then
	e_error "$usage_message"
	return	1
    fi
    if [ $# -eq 3 -a "$3" != "-r" ]
    then
	e_error "$usage_message"
	return 1
    fi
    local recursive=false
    if [ $# -eq 3 -a "$3" = "-r" ]
    then
	recursive=true
    fi

    local fav_path=$(realpath "$1")
    fav_path="/"$fav_path
    local second_path="$2"
    echo "Favorite path = [$fav_path]"
    e_header "You are going to remove duplicate files from $second_path"
    echo -n "Do you confirm (yes/no) "
    read response
    if [ "$response" != "yes" ]
    then
	return 1
    fi
    if ( $recursive )
    then
	fdupes -r --omitfirst -o name  --delete --noprompt  "$fav_path" "$second_path"
    else
	fdupes --omitfirst -o name  --delete --noprompt  "$fav_path" "$second_path"
    fi
}

reduce_pdf() {
    help_message='Usage: ${FUNCNAME[0]} <quality> <input> <output>

<quality> : screen(72dpi), ebook(150dpi), prepress(300dpi), printer (300dpi)
<input>   : pdf input file
<output>  : pdf output file
'
    if [ $# -eq 1 -a "$1" = "-h" ]
    then
        e_header "$help_message"
	return 0;
    fi
    if [ $# -ne 3 ]
    then
	e_header "$help_message"
	return 1;
    fi
    local pdfsettings="$1"
    local input="$2"
    local output="$3"

    gs -sDEVICE=pdfwrite -dCompatibilityLevel=1.4 \
       -dPDFSETTINGS=/"$pdfsettings" \
       -dNOPAUSE -dQUIET -dBATCH -sOutputFile="$output" "$input"

    res=$?
    if [ "$res" -eq 0 ]
    then
	e_success "[$output] generated successfully"
	echo
	e_arrow "$(du -sh $input)"
	e_arrow "$(du -sh $output)"
	return 0;
    else
	e_error "Failed to generate [$output]"
	return $res
    fi
}

